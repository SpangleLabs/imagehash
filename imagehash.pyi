from collections.abc import Callable
from typing import Literal
from typing_extensions import TypeAlias

import numpy as np
import numpy.typing as npt
from PIL.Image import Image

NDArray: TypeAlias = npt.NDArray[np.int32]


class ImageHash:
    hash: NDArray
    def __init__(self, binary_array: NDArray) -> None: ...
    def __sub__(self, other: ImageHash) -> int: ...
    def __eq__(self, other: ImageHash) -> bool: ...
    def __ne__(self, other: ImageHash) -> bool: ...


def hex_to_hash(hexstr: str) -> ImageHash: ...
def hex_to_flathash(hexstr: str, hashsize: int) -> ImageHash: ...
def old_hex_to_hash(hexstr: str, hash_size: int = ...) -> ImageHash: ...
def average_hash(image: Image, hash_size: int = ..., mean: Callable[[NDArray], float] = ...) -> ImageHash: ...
def phash(image: Image, hash_size: int = ..., highfreq_factor: int = ...) -> ImageHash: ...
def phash_simple(image: Image, hash_size: int = ..., highfreq_factor: int = ...) -> ImageHash: ...
def dhash(image: Image, hash_size: int = ...) -> ImageHash: ...
def dhash_vertical(image: Image, hash_size: int = ...) -> ImageHash: ...
def whash(image: Image, hash_size: int = ..., image_scale: int | None = ..., mode: Literal['haar', 'db4'] = ..., remove_max_haar_ll: bool = ...) -> ImageHash: ...
def colorhash(image: Image, binbits: int = ...) -> ImageHash: ...


class ImageMultiHash:
    segment_hashes: list[ImageHash]
    def __init__(self, hashes: list[ImageHash]) -> None: ...
    def __eq__(self, other: ImageMultiHash) -> bool: ...
    def __ne__(self, other: ImageMultiHash) -> bool: ...
    def __sub__(self, other: ImageMultiHash, hamming_cutoff: float | None = ..., bit_error_rate: float | None = ...) -> float: ...
    def hash_diff(self, other_hash: ImageMultiHash, hamming_cutoff: float | None = ..., bit_error_rate: float | None = ...) -> tuple[int, int]: ...
    def matches(self, other_hash: ImageMultiHash, region_cutoff: int = ..., hamming_cutoff: float | None = ..., bit_error_rate: float | None = ...) -> bool: ...
    def best_match(self, other_hashes: list[ImageMultiHash], hamming_cutoff: float | None = ..., bit_error_rate: float | None = ...) -> float: ...


def crop_resistant_hash(image: Image, hash_func: Callable[[Image], ImageHash] | None = ..., limit_segments: int | None = ..., segment_threshold: int = ..., min_segment_size: int = ..., segmentation_image_size: int = ...) -> ImageMultiHash: ...
